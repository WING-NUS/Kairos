<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>ENASE 2008 - 3rd International Working Conference on Evaluation of Novel Approaches to Software Engineering</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="Keywords" content="">
<meta name="Description" content="">
<link rel="stylesheet" href="style.css" type="text/css" />

<SCRIPT language=JavaScript>
<!--
function SymError()
{
  return true;
}

window.onerror = SymError;

var SymRealWinOpen = window.open;

function SymWinOpen(url, name, attributes)
{
  return (new Object());
}

window.open = SymWinOpen;

function MM_swapImgRestore() { //v3.0
  var i,x,a=document.MM_sr; for(i=0;a&&i<a.length&&(x=a[i])&&x.oSrc;i++) x.src=x.oSrc;
}

function MM_preloadImages() { //v3.0
  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();
    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)
    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}
}

function MM_findObj(n, d) { //v4.01
  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {
    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}
  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];
  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document);
  if(!x && d.getElementById) x=d.getElementById(n); return x;
}

function MM_swapImage() { //v3.0
  var i,j=0,x,a=MM_swapImage.arguments; document.MM_sr=new Array; for(i=0;i<(a.length-2);i+=3)
   if ((x=MM_findObj(a[i]))!=null){document.MM_sr[j++]=x; if(!x.oSrc) x.oSrc=x.src; x.src=a[i+2];}
}
//-->
</SCRIPT>
</head>

<body leftmargin="0" topmargin="17" rightmargin="0">
<div align="center"> 
  <table width="970" border="0" cellpadding="0" cellspacing="0" bgcolor="ffffff" height="914">
    <!--DWLayoutTable-->
    <tr>
      <td height="130" colspan="3" valign="top"><img src="Images/up.jpg" width="970" height="130"></td>
    </tr>
	<tr>
      <td width="209" height="20">&nbsp;</td>
      <td width="20">&nbsp;</td>
      <td width="741">&nbsp;</td>
	</tr>
	<tr>
	  <td height="6344" valign="top">
	    <table width="100%" border="0" cellpadding="0" cellspacing="0">
	      <!--DWLayoutTable-->
	      
	      <tr> 
	        <td height="32" valign="middle" background="Images/menu.jpg" class="menu"><a href="index.htm" class="menu">&nbsp;&nbsp;Home</a></td>
          </tr>
	      
	      
	      
	      <tr> 
	        <td height="17"></td>
          </tr>
	      
	      <tr>
	        <td height="32" valign="middle" background="Images/menu.jpg" class="menu">
            <a class="menu" href="Call_for_Papers.htm">&nbsp;&nbsp;Call for Papers			</a></td>
          </tr>
	      <tr>
	        <td height="15"></td>
          </tr>
	      
	      <tr>
	        <td height="32" valign="middle" background="Images/menu.jpg" class="menu">
            <a class="menu" href="Committees.htm">&nbsp;&nbsp;Committees</a></td>
          </tr>         <tr>
            <td height="15"></td>
              </tr>
	      
	      
	      
	      <tr>
	        <td height="32" valign="middle" background="Images/menu.jpg" class="menu">
            <a class="menu" href="Goals_Motivation.htm">&nbsp;&nbsp;Goals and Motivation			</a></td>
          </tr>
	      <tr>
	        <td height="15"></td>
          </tr>
	      
	      <tr>
	        <td height="32" valign="middle" background="Images/menu.jpg" class="menu">
            <a class="menu" href="Topics_Interest.htm">&nbsp;&nbsp;Topics of Interest</a></td>
          </tr>
	      
	      
	      
	      <tr>
	        <td height="15"></td>
          </tr>
	      
	      <tr>
	        <td height="32" valign="middle" background="Images/menu.jpg" class="menu"><a href="keynotes.htm" class="menu">&nbsp;&nbsp;Keynote Lectures</a></td>
          </tr>
	      <tr>
	        <td height="6075"></td>
          </tr>
          </table></td>
      <td>&nbsp;</td>
	  <td rowspan="2" valign="top">
		<table width="741" border="0" cellpadding="0" cellspacing="0" height="675">
		  <!--DWLayoutTable-->
		  <tr>
		    <td width="741" height="36" valign="top" class="menuTitles">Abstracts</td>
          </tr>
		  <tr>
		    <td height="19" valign="top"><!--DWLayoutEmptyCell-->&nbsp;</td>
          </tr>
		  <tr>
		    <td height="114" valign="top">            <table width="100%" border="0" cellspacing="10">
		      <!--DWLayoutTable-->
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">7</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">TOWARDS A SEMIFORMAL DEVELOPMENT METHODOLOGY FOR EMBEDDED SYSTEMS</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Lucas Cordeiro, Raimundo Barreto and Meuse Oliveira</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">In recent years, discrete control systems play an important role in the development and advancement of modern civilization and technology. This kind of system maybe classified as an embedded real-time system and requires rigorous methodologies to develop the software that is under stringent hardware constraints. Therefore, the proposed development methodology adapts agile principles and patterns in order to build embedded control systems focusing on the issues related to the system's constraints and safety. Moreover, platform-based design approach is used to balance costs and time-to-market in view of performance and functionality constraints. We conclude that the proposed methodology reduces significantly design time and cost as well as leads to better software modularity and reliability.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">10</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">METRICS FOR A MODEL DRIVEN DEVELOPMENT CONTEXT</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Motoshi Saeki and Haruhiko Kaiya</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">In a Model Driven Development context, in addition to the metrics of models themselves, the metrics of model transformation should be considered in order to measure its various characteristics such as quality.
        In this paper, we propose the technique to define the metrics of model transformation using a meta-modeling technique and a graph rewriting techniques. The meta-modeling technique is used for defining model-specific metrics, while graph rewriting rules formalize transformation.
        The values of model-specific metrics to be calculated are attached to graph rewriting rules, and can be evaluated and propagated between the models during the 
        transformation.
        The evaluation and propagation methods can be defined within the graph rewriting 
        rules, and their evaluation and propagation result in the metric values of the transformation.
        Furthermore the paper includes the example of transforming object models into relational DB models in order to show the usefulness of our approach.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">13</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">PROGRAMMING IN PROTOCOLS - A Paradigm of Behavioral Programming</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Ashley McNeile and Ella Roubtsova</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">We present work in the creation of a programming paradigm based on the event protocols of objects. Our claim is this results in a high level executable language that bridges the gap between behavioral models and code for a large class of systems. The language is based on the idea of composing partial behavioral descriptions using process algebraic techniques.
        We show that the concepts forming the basis of this language shed light on questions relating to the description of behavior in object models, particularly in the areas of reuse, abstraction, and behavioral conformance.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">21</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">MODELING QUALITY ATTRIBUTE VARIABILITY</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Eila Niemelä, Antti Evesti and Pekka Savolainen</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Due to the emerging service orientation, the importance of quality aspects and the ability to manage the changing quality requirements of a service have raised the question of how to explicitly define quality requirements and how to assure that quality requirements are handled in the same way by all service developers. Variation related to evolution qualities is managed by applying appropriate styles and patterns at design time but there is no solution for describing variation of execution qualities, such as reliability and security, in architecture models. The contribution of this paper is a novel approach, which enhances quality-driven architecture design by ontology orientation and allows 1) to define metrics for quality attributes as quality ontologies, 2) to specify execution qualities as quality profiles according to a quality variability model and quality ontologies defined, and 3) to model quality properties as an integrated part of software architecture. The use of Unified Modeling Language (UML) and its extension mechanisms guarantees that the quality profiles are specified in a uniform, understandable and sharable way and that the design specifications can be used as service descriptions exploited in run-time service adaptation. The new approach is supported by an integrated tool chain developed on top of the Eclipse platform.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">28</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">CASE STUDY: RUNNING TEST CASES FOR SEQUENTIAL PROGRAMS IN PARALLEL IN A CLUSTER ENVIRONMENT</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">P. Kroha and V. Vychegzhanin</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Testing a software system consists of a test case construction and of running and evaluating them, i.e. comparing expected results with obtained results. Because the set of test cases is usually very large, some methods of automation may be used to run them. Usually, test cases run on the same machine where the tested software system should run later. In our case, we run the test cases of a software system for a sequential computer on a cluster in parallel. The goal is to accelerate the process of running and evaluating tests. In this paper we describe the architecture of our test execution tool, experiments, and obtained results concerning performance and efficiency of test automation of sequential programs in a cluster environment.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">47</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">AUTOMATING WORKFLOWS IN MEDIA PRODUCTION - Building an Infrastructure for a Service Oriented Architecture with a Business Process Management System</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Steven Van Assche, Dietrich Van der Weken, Bjorn Muylaert, Stein Desmet and Bruno Volckaert</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">This paper describes our experiences with building an infrastructure for automating workflows in media production based on service oriented architecture (SOA). An SOA deals with distributed software services that interact with each other. By adopting an SOA in cooperation with a Business Process Management System (BPMS) we aimed at increased efficiency and control, shorter setup times, and increased flexibility. We used open source or free products where possible, and the end result is a professional architecture suitable for small-scale to medium-scale media enterprises. Key concepts are the use of JMS as messaging layer for asynchronous, long-running service interactions (which are typical in a media production environment), the orchestration of services leading to processes with more business meaning, the graphical description of these business processes followed by the automatic generation of executable code (BPEL), support for human interactions in the processes and compliance with the WS-I Basic Profile 1.1. Our architecture is illustrated with a use case in which we automated a process that deals with the intake, review, transcoding and publishing of user-generated content.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">52</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">WORKFLOW AUTOMATION FOR SYSTEM ARCHITECTING</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Markku Turunen, Kari Leppänen and Sari Leppänen</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Managing the ever-growing complexity of even 
        mass-market products, such as mobile phones, is becoming increasingly hard
        without the adoption of improved system development 
        methods, such as model-based development. To allow industrial use of such
        methods, tools that are able automate development tasks as far
        as possible are needed. In this paper, we present a partly automated system design
        flow based on the Lyra method with UML 2.0 language and Telelogic Tau G2 modeling tool. We discuss
        how the tool was extended to support automation of some central tasks
        in Lyra and show a running example of the design flow. In the example,
        a telephony functionality of a mobile device is modeled producing an
        executable specification for the system. The efficiency gains from the automation are promising.
  </div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">54</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">SEMANTIC APPLICATION DESIGN</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Philippe Larvet</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">This paper presents a process to determine the design of an application by optimizing the network of semantic components that compose the application. An application has to implement a given specification. We consider this specification is made of atomic requirements, logically linked together. On one hand, each requirement is expressed in natural language; this expression is seen as the semantic description of the requirement. On the other hand, the off-the-shelf components from which we want to build the application can also be described through a semantic description, which we call a "semantic card". Within this context, we consider the a component implements a requirement if the "semantic distance" between their two semantic descriptions is minimal. Consequently, building an application consists in building and optimizing the logical network of all the semantic optimal couples "requirement-component". The paper presents such a building and optimization automatic process, of which one of the main advantages is to derive systematically the finding and assembly of components from the written specification of the application.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">58</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">EVALUATION OF BPMN MODELS QUALITY - A Family of Experiments</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Elvira Rolón, Félix García, Francisco Ruiz, Mario Piattini, Corrado Aaron Visaggio and Gerardo Canfora</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">The design phase is of special importance in the development of a business process. This phase refers to the modeling, handling and redesigning of processes, but when maintenance tasks have to be performed, this stage can be rather complicated. It implies a heavy investment of time and resources, since it involves both technical developers and business analysts. Moreover, process modeling should permit not only the production of models which are understandable to the users, but also the early detection and correction of errors. All of this adds to the overall quality of the model. We therefore propose a set of measures with which to assess the structural complexity of conceptual business process models. Our aim is to obtain useful indicators for when we are carrying out maintenance tasks on these models. Another goal is to make it possible to carry out an early evaluation of given quality properties of the model. With the development of a family of experiments, it has been possible to discover a set of measures which may be useful in assessing the usability and maintainability of conceptual business process models.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">63</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">IMPLEMENTING ORGANIC COMPUTING SYSTEMS WITH AGENTSERVICE</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Florian Nafz, Frank Ortmeier, Hella Seebach, Jan-Phillip Steghöfer and Wolfgang Reif</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Designing and implementing Organic Computing systems is typically a difficult task. To
        facilitate the construction a design pattern for Organic Computing systems has been
        developed. This organic design pattern (ODP) helps in modeling and designing a broad
        class of Organic Computing systems.
        
        This paper focuses on the implementation of Organic Computing systems with the help of
        this pattern. The core idea is to provide a generic implementation by mapping ODP
        artifacts to artifacts of a multi-agent framework. The used framework -- AgentService --
        is one of the few C# multi-agent frameworks. In this paper a possible implementation as
        well as benefits and limitations are described.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">64</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">ON-THE-FLY INTERPRETATION OF TEST CASES IN AN AUTOMATICALLY GENERATED TTCN-3 TEST SUITE</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Winfried Dulz</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">The TestUS framework (Statistical Testing based on use case scenarios), developed at the University of Erlangen-Nuremberg, offers unique techniques and tools to obtain a TTCN-3 test suite starting from UML 2.0 requirement definitions. Use case diagrams that contain functional and non-functional requirements are transformed to a Markov Chain usage model (MCUM) in a completely automatic approach. The annotation of outgoing MCUM transitions by probabilities in the derived UML2 protocol state machine enables the generation of TTCN-3 test cases according to the expected occurrence frequencies of the specified usage pattern. One drawback in our previous approach resulted from the fact that there exist numerous test cases for a realistic SUT (System under Test). Creating and in particular compiling the TTCN-3 test suite took a long time. Consequently, we decided for the TestUS framework to map the MCUM directly into the executable test suite. Thus, the previous generation of test cases to derive the test suite is no longer necessary. Test cases and the evaluation of test verdicts are now interpreted on-the-fly in an executable TTCN-3 test suite that represents the MCUM. We also proved the new concept by means of a realistic case study for testing a DECT communication system. The previous compilation time for the dedicated DECT test suite in the order of 20 hours was reduced to only 15 minutes and we got a TTCN-3 test suite at the end that interprets as many test cases as one likes for the DECT system on-the-fly.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">65</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">AGILE METHODS AND REQUIREMENTS ENGINEERING IN CHANGE INTENSIVE PROJECTS</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Martin Fritzsche</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">In this paper we discuss how well agile methods can deal with requirements related issues in change intensive projects. Five agile methods are considered: eXtreme Programming, Scrum, Crystal, Dynamic Systems Development Method and Adaptive Software Development. We analyze how well these methods implement the basic goals of requirements engineering, how they counteract or support the occurrence of requirements changes and how they cope with problems arising from changing requirements. We show that agile methods provide a valid approach for requirements related issues, but also identify their weaknesses.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">68</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">EVALUATING MAS ENGINEERING TOOLS</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Emilia Garcia, Adriana Giret and Vicente Botti</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Recently a great number of methods and frameworks to develop multiagent systems have appeared. Nowadays there no an established framework to evaluate environments to develop multiagent system and choosing between one framework or another is a difficult task. The main contributions of this paper are: (1) an analysis of the state of the art in the evaluation of MAS engineering; (2) a complete list of criteria that allows the evaluation of multiagent system development environments;(3) a quantitative evaluation technique;(4) an evaluation of the methodology Ingenias and its development environment using this evaluation framework.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">70</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">PROCESS-CENTRIC ENTERPRISE MODELING & MANAGEMENT (ProCEM®)</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Erich Ortner</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">The shortage of skilled IT-staff as well as the technological possibilities offered by Service-oriented Architectures (SOA) and Web 2.0 applications, leads us to the following consequences: working processes, job engineering and labor organization are going to be modeled and therefore made digital in the sense of IT-support. This goes along with modeling working processes being independent from the individual employee in areas to be rationalized resp. not to be staffed by qualified specialists. Hence, there will be a worldwide net based selection of those who are able and skilled to fulfill modeled work like e.g. “handling a damage event” or “creating an optimized data structure for master data” by means of the Unified Modeling Language (UML) in the most effective and efficient way. An enterprise will therefore neutrally manage its IT-services (application programs) taking place as computer supported work equipment in any working process being located anywhere in the world without assigning it first to a specific performer. By doing so it is possible to control and dynamically execute working processes globally based on the division of labor, and on a data base supported administration of “bills of activities” by means of the World Wide Web. All that requires new and dynamic – in the sense of component based – job descriptions exceeding today’s established skill and task management by far.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">71</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">CHALLENGES FOR AGILE DEVELOPMENT OF COTS COMPONENTS AND COTS-BASED SYSTEMS - A Theoretical Examination</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Iva Krasteva, Per Branger and Rikard Land</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Component-based software engineering has had great impact in the desktop and server domain and is spreading to other domains as well, such as embedded systems. Agile methods is another approach which have gained much attention in recent years, mainly for smaller-scale, not so critical development on commission. Both promise to increase system quality, development speed and flexibility, but so far little or nothing has been published on the combination of the two approaches. This paper presents a comprehensive analysis of the applicability of the agile approach in the development processes of COTS and COTS-based systems. The study method is a systematic theoretical examination and comparison of the fundamental concepts and characteristics of these approaches. The findings are: first, an enumeration of identified contradictions between the approaches, and solution suggestions how to bridge these incompatibilities to some extent. Second, the paper provides some more general comments, considerations, and application guidelines concerning the introduction of agile principles into the development of components or component-based systems. This study thus forms a framework which will guide further empirical studies.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">72</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">SOFTWARE SEMANTIC PROVISIONING - Actually Reusing Software</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Savino Sguera, Philippe Ombredanne, Armando Stellato and Maria Teresa Pazienza</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Delivering component-oriented architectures is a well-established trend in software engineering and development. Assessing software reuse scenarios goes much beyond the usual “build vs buy” dilemma that so often occurs in early stages of a software process: scouting, comparing, choosing and integrating the right set of components meeting project’s requirements is still an ad-hoc and error-prone task, performed by developers with little or no frameworks and tools to support them. This paper describes the SSP (Semantics-Driven Software Provisioning) project, funded in its early stages by GoogleTM Inc., developed during the Google Summer of CodeTM 2007 program, and incubated by the Eclipse Software Foundation; the project aims to provide an ontological description of the software domain to underlie a semantic web framework for supporting developers in scouting and provisioning software components. A prototypical RESTful semantic repository, and an Eclipse plug-in consuming the repository services have been implemented and will be discussed.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">77</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">BALANCED GOALCARDS - Combining Goal Analysis and Balanced Scorecards</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Alberto Siena, Alessio Bonetti and Paolo Giorgini</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Today's Information Systems are complex systems that have to deal with a variety of different and potentially conflicting needs.
        Capturing their strategic requirements is a critical activity, as it must answer at the same time to software and corporate goals.
        In this paper, we introduce the economic foundations of strategic requirements. We propose a novel conceptual framework for requirements modeling and validation, based on economic and business strategy theory.
        The soundness of the framework is also evaluated, by presenting the result of its application to a real case study.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">84</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">RANDOM VS. SCENARIO-BASED VS. FAULT-BASED TESTING - An Industrial Evaluation of Formal Black-Box Testing Methods</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Martin Weiglhofer and Franz Wotawa</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Given a formal model of a system under test there are different strategies in order to systematically derive test cases from such a model. These strategies are based on different underlying testing objectives and concepts. Obviously, their usage has impact on the generated test cases. In this paper we evaluate random, scenario-based and fault-based test case generation strategies in the context of an industrial application and assess the advantages and disadvantages of these three strategies. The derived test cases are evaluated in terms of coverage and in terms of the detected errors on a commercial and on an open source implementation of the Voice-Over-IP Session Initiation Protocol.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">85</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">ON THE PERFORMANCE OF FAULT SCREENERS IN SOFTWARE DEVELOPMENT AND DEPLOYMENT¤</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Rui Abreu, Alberto González, Peter Zoeteweij and Arjan J. C. van Gemund</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Fault screeners are simple software (or hardware) constructs that detect variable value errors based on unary invariant checking. In this paper we evaluate and compare the performance of two low-cost screeners (Bloom filter, and range screener) that can be automatically integrated within a program, while being automatically trained during the testing phase. While the Bloom filter has the capacity of retaining virtually all variable values associated with proper program execution, this property comes with a much higher false positive rate per unit training effort, compared to the more simple range screener, that compresses all value information in terms of a single lower and upper bound. We present a novel analytic model that predicts the false positive and false negative rate for both type of screeners. We show that the model agrees with our empirical findings. Furthermore, we describe the application of both screeners, where the screener output is used as input to a fault localization process that provides automatic feedback on the location of residual program defects during deployment in the field.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">88</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">VISUAL COMPOSITION OF COMPONENT SYSTEMS</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Hans Albrecht Schmid and Christian Martin Baranowski</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Component composition has been over a decade a concept that supplements classical reference-based programming, but does not replace it to a larger extent. Though a new generation of component languages like ArchJava has pushed forwards composition from subcomponents, these languages fall back into class-based programming of methods when Java program code is to be written e.g. as a filter among subcomponents. To allow for a seamless composition process, we have developed the component language CompJava that introduces component fragments and plugs as means for composing a component both from subcomponents and structured units of code. In parallel, we have extended UML 2 component diagrams by the newly introduced concepts. This allows visualizing the compositional structure of components in order to better understand and communicate it. A graphical editor, called CompJava Designer, allows constructing relatively complex and distributed component systems by a seamless visual composition process.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">94</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">MODELING OF SERVICE ORIENTED ARCHITECTURE - From Business Process to Service Realisation</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Marek Rychlý and Petr Weiss</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">This paper deals with modeling of Service-Oriented Architecture (SOA). SOA is an architectural style for analysis, design, maintaining and integration of enterprise applications that are based on services. Services are autonomous platform-independent entities that enable access to one or more capabilities, which are accessible by a provided interface. The goal of SOA is to align business and IT architectures. Hence, a new designed service has to meet business requirements that are traditionally specified by a business process diagram. The approach, presented in this paper, helps to bridge the semantic gap between business requirements and IT architecture by using a method for transformation of business processes diagrams into services diagrams. In particular, the method deals with process realisation based on services, and it describes choreographing of services towards fulfilling business goals.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">115</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">BUSINESS PROCESS MODELING AWARE TO THE  ENVIRONMENT CHANGES - A Pattern Driven Approach</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Nicola Boffoli, Daniela Castelluccia, Fabrizio Maria Maggi and Roberto Rutilo</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Nowadays enterprises perform in an extremely competitive business environment, therefore business processes, although complex, must be highly flexible to react to the new demands. This purpose implies that these processes should be continuously maintained through a flexible modeling. This paper addresses this problem and provides a process modeling approach able to govern the high variability of the environment parameters affecting the processes in use, through the well known pattern paradigm and the decision tables formalism. Furthermore, the authors discuss the experience of the proposed approach in a real case. Results are encouraging and drive further investigations in such a way. </div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  <tr> 
    <td width="73" height="21" class="textoNormalBold"><div align="right">Paper Nr.:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">119</div>      </td>
    </tr>
		      <tr> 
		        <td width="73" height="21" class="textoNormalBold"><div align="right">Title:</div></td>
      <td width="703" valign="middle" class="textoNormal"><div align="justify">TYPED ABSTRACTIONS FOR CLIENT-SERVICE INTERACTIONS IN OSGI</div>      </td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Author(s):</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">Sven De Labey and Eric Steegmans</div></td>
    </tr>
		      <tr> 
		        <td height="21" class="textoNormalBold"><div align="right">Abstract:</div></td>
      <td valign="middle" class="textoNormal"><div align="justify">The Open Services Gateway initiative (OSGi) is a successful attempt to bridge the gap between Java and Service Oriented Computing. OSGi provides an LDAP-based query language for fine-tuning service retrieval and offers an eventing mechanism that signals changes to a service’s lifecyle to all clients depending on that service. Nonetheless, a number of challenges remain unsolved. OSGi’s service query language, for instance, bypasses important compile-time guarantees on the syntactical correctness of queries and the language works only for properties that never change during the lifetime of a service. What programmers need, however, is a statically type-checked, robust query language that takes into account dynamically evolving, volatile service characteristics. A second problem is that the lifecycle management system requires programmers to write a considerable amount of boilerplate logic for reacting to service events. This obfuscates the business logic, which in turn decreases code comprehension and increases the odds for introducings bugs when implementing client-service interactions.
        
        This paper evaluates OSGi as a platform for programming client-service interactions in Java. After focusing on a number of shortcomings of OSGi’s integrated service query language and its lifecycle management system, we propose a solution based on a programming language extension. After the conceptual definition of these new language concepts, we show how they can be transformed to regular Java code without losing interoperability with the OSGi standard.</div></td>
    </tr>
		      <tr> 
		        <td height="23" colspan="2" valign="top"><hr></td>
    </tr>
		      
  </table>          </td>
          </tr>
		  <tr>
		    <td height="17"></td>
	      </tr>
        </table></td>
    </tr>
	<tr>
	  <td height="50">&nbsp;</td>
	  <td>&nbsp;</td>
    </tr>
	
	

	<tr>
      <td height="89" colspan="3" valign="top"><table width="100%" border="0" cellpadding="0" cellspacing="0">
          <!--DWLayoutTable-->
          <tr> 
            <td width="970" height="19" valign="top"><!--DWLayoutEmptyCell-->&nbsp;</td>
          </tr>
          <tr> 
            <td height="17" valign="middle" class="textoNormal"><div align="center">....................................................................................................................................................................................................................................................</div></td>
          </tr>
          <tr> 
            <td height="52" valign="top" class="smallText"><div align="center">The ENASE web site is developed and maintained by: <a href="http://www.insticc.org" class="smallText" target="_blank">INSTICC</a> <br>
                Copyright &copy; 2006-2007 <a href="http://www.insticc.org" class="smallText" target="_blank">INSTICC</a><br>
                <br>
                <em>Page updated on 
                <!-- #BeginDate format:Fr1 -->2/04/09<!-- #EndDate -->
                </em> </div></td>
          </tr>
      </table></td>
    </tr>
  </table>
</div></body>
</html>
